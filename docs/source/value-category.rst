
值与对象
================

在理解 `Moden C++` 的各种令人眼花缭乱的特性之前，必须先搞清楚两个基本概念，这是理解很多特性的基础。
而这两个概念就是： **对象** （Object）和 **值** （Value）。


值
-----------

我们先来看看什么是 **值** 。

简单说， **值** 是一个纯粹的数学抽象概念，比如数字 ``10`` ，或者字符 ``'a'`` , 或者布尔值 ``false`` ，等等。它们完全不需要依赖于计算机或者内存而存在，就只是一个纯粹的值：不需要存储到内存，当然也就不可修改。注意，这与存储在内存中，但immutable完全不是一个语意。

那么 ``1+2`` 呢？这是一个表达式，但这个表达式的求值结果也是一个 **值** 。因而，这是一个值类别的表达式 。
而数字 ``10`` 同样是一个表达式，其求值的结果毫无疑问也是一个 **值** ——它自身。
因而，在这个角度， ``1+2`` 和数字 ``10`` ，从性质上没有任何区别，都是 **值** 类别的表达式。


对象
---------------


我们再来看看什么是 **对象** 。

对象是一个在内存中占据了一定空间的有类型的东西。因而，它必然是与计算机内存这个物理上具体存在的设备关联在一起的一个物质。

因而，每一个对象都必然有一个 **标识** （Identifier），从而你可以知道这个对象在内存中唯一的起始位置。否则，对象是一个与内存关联在一起的物质就无从谈起。

所以 ``int i`` 就定义了一个对象，系统必然会在内存中为其分配一段 ``sizeof(int)`` 大小的空间，而 ``i`` 就是这个对象的标识。

既然对象与内存有关联，并且有自己区别于其它对象的唯一起始内存地址，那么任何对象都必然可以被引用。引用做为一个对象的别名，当然也是对象的一种 **标识** 。

所以，区分 **对象** 和 **值** 的方法非常简单：是否有 **标识** ，或可否被 **引用** （毕竟引用就是一种标识）。只有做为具体内存物质的对象才可能被引用；而值，做为一种抽象概念， 引用无从谈起。


值与对象的关系
------------------------------

那么 **值** 和 **对象** 之间是什么关系？

很简单， **值** 用来初始化 **对象** 。比如： ``bool b = true`` ,
其语意是：用值 ``true`` 初始化对象 ``b`` ；类似的，``int i = 1 + 2``  表示用值 ``1+2`` 的计算结果值，
初始化对象 ``i`` 。 **对象** 表示内存中的一段有类型的空间， **值** 这则是个空间里的内容。 用 **值** 来初始化 **对象** 的过程，
是一个将值加载到空间的隐喻。


纯右值
---------

所有的 **值** 语意的表达式，都归类为 **纯右值** （pure right value，简称prvalue）。在 `C++11` 之前，它们被称做 **右值** 。

其存在的唯一的目的，是为了初始化 **对象** 。单独写一个 **纯右值** 表达式，比如： ``1+2`` ，或者 ``true && (1 == 2)`` ，
语法和语意上虽然允许存在，但编译器往往会将其优化掉。
除非，发现某个纯右值表达式的求值过程会对系统产生副作用（比如在构造函数里进行了标准输出）。

而既然是一个 **值** ，就必须是某种具体类型的值，而不可能是某种 **不完备类型** 。当然也不可能是一个 **抽象类型** （包含有纯虚函数的类）的值，即便其基类是某种抽象类型，但它自身必然是一个具体类型，因而对其任何 ``virtual`` 函数的调用，都是对其具体类型所对应的函数实现的调用。

同时，你不可能对一个值进行取地址操作（语意上就不通），也不可能引用它。


泛左值
---------

与 **纯右值** 对应的是 **泛左值** （glvalue）。整个表达式的世界被分为这两大类别。前者全部是 **值** 语意，后者全部是 **对象** 语意。

如果没有 **右值引用** 的引入， **泛左值** 则是传统意义上的 **左值** 。


左值
+++++++++

左值很容易辨别：任何可以对其通过符号 ``&`` 取地址的表达式，都属于 **左值** 。因而，任何变量（包括常量），无论是全局的，还是类成员的，还是函数参数，还是函数名字，都肯定属于左值。

另外，所有返回值是左值引用的函数调用表达式（包括用户自定义的重载操作符），以及 ``static_cast<T&>(expr)`` 都必然也属于左值。毕竟，没有内存中的对象，哪里来的引用？而引用无非是对象的一个别名标识罢了。

剩下的就是系统的一些builtin操作符的定义，比如对一个指针求引用操作： ``*p`` ，或者 ``++i`` 。

其中，最为特殊的是字符串字面常量，比如： ``"abcd"`` ，这是一个左值对象。这有点违背直觉，但由于C/C++中字符串并不是一个builtin基本类型。这些字符串字面常量都会在内存中得以存储。

需要注意的是，这两种情况下，无论是变量 ``i`` ，还是函数参数 ``r`` ，它们都是一个 **左值** ，虽然它们的类型是 **右值引用** 。我们之前谈到过，任何变量，无论其属于什么类型，都必然是一个左值。变量的名字，就是对应对象的标识。


速亡值
++++++++++++++++

`C++11` 之前，表达式的世界很单纯，只有 **左值** 和 **右值** 之分。其中 **左值** 正是上面所描述的 **左值** ；而 **右值** 则对应上述的 **纯右值**。

到了 `C++11` ，引入了一种新的构造对象的方式：移动构造（move cons)。比如下面的例子：

.. code-block:: c++

   void f(const Foo& foo) {
      // ...
      Foo newFoo{foo};
   }

在没有移动构造之前，这是一个典型的 ``copy`` 语意。因而 ``f(Foo{10})`` 这样的调用，即便传入的是一个临时对象，也只能copy它，
而不能复用其资源。虽然这个临时对象在调用结束后，已经不再存在。

而移动构造的引入，就给用户多提供了一种选择，如果想复用一个对象的资源，就move构造，否则，依然copy构造。

但怎么区分这两种情况呢？毕竟构造函数是一种重载场景，并且原来的引用类型不足以满足传入可修改临时对象的场景（非常量左值引用只能引用左值，
常量左值引用类型虽可以引用一个临时对象，但不能修改），所以引入了一种新的引用类型：右值引用。从而就可以定义如下不同的构造：

.. code-block:: c++

   struct Foo {
      Foo(int i);

      Foo(const Foo&); // copy cons
      Foo(Foo&&);      // move cons

      // ...
   };

   Foo foo{10};    // 左值

   Foo foo1{foo1}    // copy cons
   Foo foo2{Foo{20}} // move cons

一切看起来都很完美。但右值引用的引入带来了一个新问题：既然函数的参数可以是一个右值引用，那么用户自然也可以随时随地的定义其它右值引用变量。比如：

.. code-block:: c++

   Foo&& foo = Foo{10};

而和左值引用不同的是，这样的右值引用变量定义，必须考虑其所引用的临时对象的生命周期问题。
这个不难解决，只需要让临时对象的生命周期和右值引用变量相同即可：

.. code-block:: c++

   {
      Foo&& foo = Foo{10}; // 临时对象的生命周期被扩展到和foo一样久

      // ...
   }
   // 离开scope后，foo生命周期结束，临时对象的生命周期也随之结束

而一旦定义了这样一个引用，很多性质也就和一个左值引用没有区别，比如：

.. code-block:: c++

   Foo&& foo = Foo{10};

   Foo* p = &foo; // 当然可以取地址

   void f(Foo&);

   f(foo); // 当然也应该可以调用

但很快就有带来了一个新问题，一个右值引用类型的变量，在初始化一个对象时，是否应该选择 ``move cons`` 。直观的看，应该。
毕竟变量的类型和 ``move cons`` 类型完全匹配。

.. code-block:: c++

   Foo&& foo = Foo{10};

   Foo fooObj{foo}; // move

   foo.a += 10;     // 非法访问，因为foo的资源已经被move

这就带来了一个很tricky的问题，一方面，程序员知道那个临时对象的生命周期，和 ``foo`` 一致，但只是中间某个地方隐式的
调用了 ``move`` 构造，自己所持有的对象，突然陷入了资源被劫掠的状态。这很容易导致程序员不小心写出错误的代码。
除非在安全的情况（比如: ``Foo foo { Foo{10} }`` ），或者用户明确指明的情况，不应该允许自动的 ``move`` 走一个对象的资源。
这样才能尽可能帮助程序员写出健壮的代码。

另外，既然提供了这样一种新的引用类型，程序员定义一个右值引用变量的动机是什么？一定是为了 ``move`` 吗？未必，或许程序员
只是很喜欢它可以直接引用一个临时变量，并且还可以修改其值。而这一点在之前是无法做到的。毕竟，一个右值引用变量被定义之后，其性质就是
一个对对象的引用而已，除了需要维持它所引用的对象生命周期之外，性质上和一个 ``non-const`` 左值引用并无差别。

但用户的确想 ``move`` 走一个对象的资源怎么办？并且除了想 ``move`` 一个右值引用所引用的对象之外，某些场景下，也想 ``move`` 一个
左值对象，或者左值引用所引用的对象咋么办？

综合以上约束，最简单明确统一的方法，就是让程序员明确的进行指定，而这个指定的手段，是类型转换。比如：

.. code-block:: c++

   Foo&& foo1 = Foo{10};
   Foo   foo2 = Foo{20};

   Foo fooObj1{static_cast<Foo&&>(foo1)}; // move
   Foo fooObj2{static_cast<Foo&&>(foo2)}; // move

   foo1.a += 10;     // 非法访问，因为foo1的资源已经被move
   foo2.a += 10;     // 非法访问，因为foo2的资源已经被move

对于左值对象的类型强转容易理解。可右值引用变量 ``foo1`` 本来类型就是 ``Foo&&`` ，再强转一下有什么不同吗？

`C++11` 将其强行定义为不同的情况。无论一个表达式原来是什么类型，表达式 ``static_cast<T&&>(expr)`` 被赋予了新的性质：
它可以自动匹配 ``move cons`` ，当然，一旦匹配了 ``move cons`` ，经过 ``move`` 之后，
这个右值引用所引用的对象，其内容很快就会过期或失效。

所以，对于这类表达式， `C++11` 将这类表达式命名为： **速亡值** （eXpire Value或xvalue)。

除了 ``static_cast<T&&>(expr)`` 之外，所有返回值类型为右值引用类型的函数，其调用表达式也都属于 **速亡值** 。
从而，我们就可以很便利的写出任意复杂度的函数，最终返回的结果，可以直接匹配 ``move cons`` 。

不难看出，虽然类型都是右值引用，但有名字的右值引用，即变量，其属于左值。而 **速亡值** 是一个 **无名右值引用** ，
其所引用的对象，从理论上同样也是可以取其地址的。但由于这类表达式存在的目的，是为了匹配 ``move`` 语意的函数。
取其地址之后，程序的其它部分将无从判断，这是一个来自于速亡值对象的地址，还是一个来自于左值对象的地址，从而容易导致危险的操作。
因而，对其取地址操作被禁止。

再强调一次， **右值引用** 类型本身并不代表 **速亡值** 。前者是 **类型** ，后者是 **表达式** 。
一个表达式的类型是 **右值引用** ，也不代表这个表达式属于 **速亡值** 。比如： ``Foo&& foo = Foo{10}`` ;
表达式 ``foo`` 的类型是一个右值引用，但它属于 **左值** 。而上述的 ``getFoo()`` 以及 ``std::move(foo)`` ，
其类型也是一个 **右值引用** ，它则属于 **速亡值** 。类似的还有 ``static_cast<Foo&&>(foo)`` ，这个表达式也属于 **速亡值** 。

但类型为右值引用的任何表达式，都必然属于 **泛左值** 。泛左值属于对象概念，右值引用也是对象的一种标识。


纯右值物质化
++++++++++++++++++++++++

上面给的那些与值有关的例子，简单而直观，不难理解它们是数学意义上的值。我们来看一个不那么直观的例子：在 ``Foo`` 是一个 ``class`` 的情况下， ``Foo{10}`` 是一个对象还是一个值？

在 `C++17` 之前，这个表达式的语意是一个 **临时对象** 。

非常有说服力的例子是： ``Foo&& foo = Foo{10}``  或者 ``const Foo& foo = Foo{10}`` 。这这两个初始化表达式里，毫无疑问 ``Foo{10}`` 是一个对象，因为它可以被引用，无论是一个右值引用 ``Foo&&`` ，还是一个左值引用 ``const Foo&``，能被引用的必然是 ``对象`` 。

但后来人们发现，将其定义为对象语意，在一些场景下会带来不必要的麻烦：

比如： ``Foo foo = Foo{10}`` 的语意是：构造一个临时对象，然后 ``copy/move`` 给左边的对象 ``foo`` 。

注意，只要 ``Foo{10}`` 被定义为 **对象** ，那么 ``copy/move`` 语意也就变得不可避免，这就要求 ``class Foo`` 必须要隐式或显式的提供 ``public copy/move constructor`` 。即便编译器肯定会将对 ``copy/move constructor`` 的调用给优化掉，但这是到优化阶段的事，而语意检查发生在优化之前。如果 ``class Foo`` 没有 ``public copy/move constructor`` ，语意检查阶段就会失败。

这就给一些设计带来了麻烦，比如，程序员不希望 ``class Foo`` 可以被 ``copy/move`` ，所有 ``Foo`` 实例的创建都必须通过一个工厂函数，比如： ``Foo makeFoo()`` 来创建；并且程序员也知道 ``copy/move constructor`` 的调用必然会被任何像样的编译器给优化掉，但就是过不了那该死的对实际运行毫无影响的语意检查那一关。

于是，到了 `C++17` ，对于类似于 ``Foo{10}`` 表达式的语意进行了重新定义，它们不再是一个 **对象** 语意，而只是一个 **值** 。即 ``Foo{10}`` 与内存临时对象再无任何关系，它就是一个 **值** ：其估值结果，是对构造函数 ``Foo(int i)`` 进行调用所产生的 **值** 。而这个 **值** ，通过等号表达式，赋值给左边的 **对象** ，正如 ``int i = 10`` 所做的那样。从语意上，不再有对象间的 ``copy/move`` ，而是直接将构造函数调用表达式作用于等号左边的 **对象** ，从而完成用 **值** 初始化 **对象** 的过程。因而， ``Foo foo = Foo{10}`` ，与 ``Foo foo{10}`` ，在 `C++17` 之后，从语意上（而不是编译器优化上），完全等价。

一旦将其当作值语意，很多表达式的理解上也不再一样。比如： ``Foo foo = Foo{Foo{Foo{10}}}`` ，如果 ``Foo foo = Foo{10}`` 与 ``Foo foo{10}`` 完全等价，那么就可以进行下列等价转换：

.. code-block:: c++

       Foo foo = Foo{Foo{Foo{10}}}
   <=> Foo foo{Foo{Foo{10}}
   <=> Foo foo = Foo{Foo{10}}
   <=> Foo Foo{Foo{10}}
   <=> Foo foo = Foo{10}
   <=> Foo foo{10}

注意，这是一个自然的语意推论，而不是编译器的优化。

自然，对于 ``Foo makeFoo()`` 这样的函数，其调用表达式 ``makeFoo()`` ，在 `C++17` 下也是 **值** 。而不是返回一个临时对象，然后在 ``Foo foo = makeFoo()`` 表示式里， ``copy/move`` 给等号左侧的对象 ``Foo`` 。虽然C/C++编译器很早就有 ``RVO/NRVO`` 优化技术；但同样，那是优化阶段的事，而不是语意分析阶段如何理解这个表达式语意的问题。

.. code-block:: c++

   Foo&& foo = Foo{10};

   Foo obj = static_cast<Foo&&>(foo);


``Foo&& foo = f()`` ，表达的是，将一个 **速亡值** 初始化给一个 **左值** 。

我们再回到前面的问题： ``Foo&& foo = Foo{10}`` 表达了什么语意？毕竟右边的是 **值** ，而左边是一个对于对象的 **引用** 。而 **引用** 只能引用一个对象，引用一个值是逻辑上是讲不通的。


这中间隐含着一个过程： **纯右值** 的 **物质化** 。即将一个 **纯右值** ，赋值给一个临时对象，其标识是一个无名字的右值引用，即 **速亡值** 。然后再将这个 **速亡值** 初始化给等号左侧的 **左值** 。

**纯右值物质化** 的过程还发生在其它场景。比如，最典型的场景，``Foo{10}`` 是一个纯右值表达式，但对于这个纯右值，我们试图访问其非静态成员，比如： ``Foo{10}.m`` ，此时就必需要将这个纯右值物质化，转化成 **速亡值** 。毕竟，对于任何非静态成员的访问，都需要对象的地址，与成员变量所代表的偏移两部分配合。没有对象的存在，仅靠偏移量访问其成员，完全无意义。

在 `C++17` 之前的规范定义中，将 **纯右值** 和 **速亡值** 合在一起，称为 **右值** 。代表它们都是可以被 ``move`` 的。在进行重载匹配时，右值会优先匹配右值引用参数。比如：

.. code-block:: c++

   void func(Foo&&);       // #1
   void func(const Foo&);  // #2

   Foo&& f();


   func(Foo{10}); // #1
   func(f());     // #1

   Foo foo{10};
   func(foo);     // #2

   Foo&& foo1 = Foo{10};
   func(foo1);    // #2


到了 ``C++17`` ，从匹配行为上没有变化，但语意上却有了变化。最终导致匹配右值引用版本的不是右值类别，而是速亡值。因为纯右值会首先进行物质化，得到一个速亡值。最终是用速亡值初始化了对应函数的参数。

而构造函数的匹配，一个纯右值，永远也无法匹配到 ``move`` 版本。因为 ``Foo foo = Foo{10}`` 与 ``Foo foo{10}`` 等价。而不再是将纯右值进行物质化，得到一个速亡值，然后匹配到 ``move`` 构造函数的过程。只有速亡值，才能匹配到 ``move`` 构造。比如： ``Foo foo = std::move(Foo{10})`` 将会导致 ``move`` 构造的调用。


另外，一个表达式是速亡值，并不代表其所引用的对象一定是一个从纯右值物质化的到的临时对象。而是两种可能都存在。比如，如果 ``foo`` 是一个左值， ``std::move(foo)`` 这个速亡值所引用的对象就是一个左值；而 ``std::move(Foo{10})`` 则毫无疑问引用的是一个物质化后的到的临时对象。

所以，**速亡值** 的含义仅仅代表：这个引用所引用的对象，可以被 ``move`` ，尤其是在调用重载函数时，会优先匹配参数类型为右值引用的版本。


.. attention::
   - 所有的表达式都可以归类为 **纯右值** 和 **泛左值** ；
   - 所有的 **纯右值** 都是 **值** 的概念；所有的 **泛左值** 都是 **对象** 的概念；
   - **左值** 可以求地址，**速亡值** 不可以求地址；
   - **纯右值** 在某些场景下会通过 **物质化** ，转化成 **速亡值** 。
   - 并非所有 **右值引用** 类型的表达式都属于 **速亡值** ；有名字的属于 **左值** ；无名字的才属于 **速亡值** ；
   - **泛左值** 可以是抽象类型和不完备类型，可以进行多态调用；**纯右值** 只能是具体类型，无法进行多态调用。

