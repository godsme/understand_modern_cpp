
值与对象
================

在理解Moden C++的各种令人眼花缭乱的特性之前，必须先搞清楚两个基本概念，这是理解很多特性的基础。而这两个概念就是：对象（Object）和值（Value）。


值
-----------

我们先来看看什么是 ``值`` 。

简单说， ``值`` 是一个纯粹的数学抽象概念，比如数字 ``10`` ，或者字符 ``'a'`` , 或者布尔值 ``false`` ，等等。它们完全不需要依赖于计算机或者内存而存在，就只是一个纯粹的值：不需要存储到内存，当然也就不可修改。注意，这与存储在内存中，但immutable完全不是一个语意。

那么 ``1+2`` 呢？这是一个表达式，但这个表达式的求值结果也是一个 ``值`` 。因而，这是一个 ``值类别的表达式`` 。而数字 ``10`` 同样是一个表达式，其求值的结果毫无疑问也是一个 ``值`` ——它自身。因而，在这个角度， ``1+2`` 和数字 ``10`` ，从性质上没有任何区别，都是 ``值`` 类别的表达式。


对象
---------------


我们再来看看什么是 ``对象`` 。

对象是一个在内存中占据了一定空间的有类型的东西。因而，它必然是与计算机内存这个物理上具体存在的设备关联在一起的一个物质。

因而，每一个对象都必然有一个 ``标识``（Identifier），从而你可以知道这个对象在内存中唯一的起始位置。否则，对象是一个与内存关联在一起的物质就无从谈起。

所以 ``int i`` 就定义了一个对象，系统必然会在内存中为其分配一段 ``sizeof(int)`` 大小的空间，而 ``i`` 就是这个对象的标识。

既然对象与内存有关联，并且有自己区别于其它对象的唯一起始内存地址，那么任何对象都必然可以被 ``引用`` 。``引用`` 做为一个对象的 ``别名`` ，当然也是 ``对象`` 的一种 ``标识`` 。

所以，区分 ``对象`` 和 ``值`` 的方法非常简单：是否有 ``标识`` ，或可否被 ``引用`` （毕竟引用就是一种标识）。只有做为具体内存物质的对象才可能被引用；而值，做为一种抽象概念， ``引用`` 无从谈起。


值与对象的关系
------------------------------

那么 ``值`` 和 ``对象`` 之间是什么关系？

很简单， ``值`` 用来初始化 ``对象`` 。比如： ``bool b = true`` , 其语意是：用值 ``true`` 初始化对象 ``b`` ；类似的，``int i = 1 + 2``  表示用值 ``1+2`` 的计算结果值，初始化对象 ``i`` 。

上面给的那些与值有关的例子，简单而直观，不难理解它们是数学意义上的值。我们来看一个不那么直观的例子：在 ``Foo`` 是一个 ``class`` 的情况下， ``Foo{10}`` 是一个对象还是一个值？

在C++17之前，这个表达式的语意是一个 ``临时对象`` 。

非常有说服力的例子是： ``Foo&& foo = Foo{10}``  或者 ``const Foo& foo = Foo{10}`` 。这这两个初始化表达式里，毫无疑问 ``Foo{10}`` 是一个对象，因为它可以被引用，无论是一个右值引用 ``Foo&&`` ，还是一个左值引用 ``const Foo&``，能被引用的必然是 ``对象`` 。

但后来人们发现，将其定义为对象语意，在一些场景下会带来不必要的麻烦：

比如： ``Foo foo = Foo{10}`` 的语意是：构造一个临时对象，然后 ``copy/move`` 给左边的对象 ``foo`` 。

注意，只要 ``Foo{10}`` 被定义为 **对象** ，那么 ``copy/move`` 语意也就变得不可避免，这就要求 ``class Foo`` 必须要隐式或显式的提供 ``public copy/move constructor`` 。即便编译器肯定会将对 ``copy/move constructor`` 的调用给优化掉。但这是到优化阶段的事，而语意检查发生在优化之前，如果 ``class Foo`` 没有 ``public copy/move constructor`` ，语意检查阶段就会失败。

这就给一些设计带来了麻烦，比如，程序员不希望 ``class Foo`` 可以被 ``copy/move`` ，所有 ``Foo`` 实例的创建都必须通过一个工厂函数，比如： ``Foo makeFoo()`` 来创建；并且程序员也知道 ``copy/move constructor`` 的调用必然会被任何像样的编译器给优化掉，但就是过不了那该死的对实际运行毫无影响的语意检查那一关。

于是，到了C++17，对于 类似于 ``Foo{10}`` 表达式的语意进行了重新定义，它们不再是一个 **对象** 语意，而只是一个 **值** 。即 ``Foo{10}`` 与内存临时对象再无任何关系，它就是一个 **值** ：其估值结果，是对构造函数 ``Foo(int i)`` 进行调用所产生的 **值** 。而这个 **值** ，通过等号表达式，赋值给左边的 **对象** ，正如 ``int i = 10`` 所做的那样。从语意上，不再有对象间的 ``copy/move`` ，而是直接将构造函数调用表达式作用于等号左边的 **对象** ，从而完成用 **值** 初始化 **对象** 的过程。因而，``Foo foo = Foo{10}`` ，与 ``Foo foo{10}`` ，在C++17之后，从语意上（而不是编译器优化上），完全等价。


一旦将其当作值语意，很多表达式的理解上也不再一样。比如： ``Foo foo = Foo{Foo{Foo{10}}}``


如果 ``Foo foo = Foo{10}`` 与 ``Foo foo{10}`` 完全等价，那么就可以进行下列等价转换：

.. code-block:: c++

       Foo foo = Foo{Foo{Foo{10}}} 
   <=> Foo foo{Foo{Foo{10}} 
   <=> Foo foo = Foo{Foo{10}}
   <=> Foo Foo{Foo{10}}
   <=> Foo foo = Foo{10}
   <=> Foo foo{10}

注意，这是一个自然的语意推论，而不是编译器的优化。

自然，对于 ``Foo makeFoo()`` 这样的函数，其调用表达式 ``makeFoo()`` ，在C++17下也是值。而不是返回一个临时对象，然后在 ``Foo foo = makeFoo()`` 表示式里， ``copy/move`` 给等号左侧的对象 ``Foo`` 。虽然C/C++编译器很早就有RVO/NRVO优化技术；但同样，那是优化阶段的事，而不是语意分析阶段如何理解这个表达式语意的问题。


纯右值
---------

所有的值语意的表达式，都归类为 **纯右值** （prvalue）。在C++11之前，它们被称做 **右值** 。

其存在的唯一的目的，是为了初始化 **对象** 。单独写一个纯右值表达式，比如： ``1+2`` ，或者 ``Foo{10}`` ，语法和语意上虽然允许存在，但编译器往往会将其优化掉。除非，发现某个右值表达式的求值过程会对系统产生副作用（比如在构造函数里进行了标准输出）。

而既然是一个 **值** ，就必须是某种具体类型的值，而不可能是某种 **不完备类型** 。当然也不可能是一个 **抽象类型** （包含有纯虚函数的类）的值。你不可能对它进行取地址操作（语意上就不通），也不可能引用它。



泛左值
---------

与 **纯右值** 对应的是 **泛左值** （glvalue）。整个表达式的世界被分为这两大类别。前者全部是值语意，后者全部是对象语意。

如果没有 **右值引用** 的引入， **泛左值** 则是传统意义上的 **左值** 。



左值
+++++++++

左值很容易辨别：任何可以对其通过符号 ``&`` 取地址的表达式，都属于 **左值** 。因而，任何变量（包括常量），无论是全局的，还是类成员的，还是函数参数，还是函数名字，都肯定属于左值。

另外，所有返回值是左值引用的函数调用表达式（包括用户自定义的重载操作符），以及 ``static_cast<T&>(expr)`` 都必然也属于左值。毕竟，没有内存中的对象，哪里来的引用？而引用无非是对象的一个别名标识罢了。

剩下的就是系统的一些builtin操作符的定义，比如对一个指针求引用操作： ``*p`` ，或者 ``++i`` 。

其中，最为特殊的是字符串字面常量，比如： ``"abcd"`` ，这是一个左值对象。这有点违背直觉，但由于C/C++中字符串并不是一个builtin基本类型。这些字符串字面常量都会在内存中得以存储。

到了C++11，引入了 **右值引用** ，其存在的唯一目的是为了能够匹配到 ``move`` 相关的操作的操作：比如 ``move`` 构造和 ``move`` 赋值。否则，右值引用没有任何意义。

有了右值引用之后，我们就可以写出类似于： ``int&& i = 10`` ，或者，如果一个函数的原型存在右值引用类型的参数，比如： ``void f(Foo&& r)``  ，可以直接以 ``f(Foo{10})`` 的方式调用。

需要注意的是，这两种情况下，无论是变量 ``i`` ，还是函数参数 ``r`` ，它们都是一个 **左值** ，虽然它们的类型是 **右值引用** 。我们之前谈到过，任何变量，无论其属于什么类型，都必然是一个左值。变量的名字，就是对应对象的标识。


速亡值
++++++++++++++++


有名字的都是左值，那没名字的呢？比如，对于原型为 ``Bar&& f()`` 的函数的调用表达式 ``f()`` ，其求值的结果是一个右值引用，因而背后必然有一个对应的内存对象。因而，我们可以写出这样的语句： ``Bar bar{foo().p}`` ；在这个语句里， ``foo()`` 所返回的那个无名字的右值引用所引用的对象，其所拥有的指针 ``p`` ，被取出并用来构造另外一个对象，等整个表达式运行结束， ``foo()`` 所返回的右值引用所引用的对象就过期，也就是说，不再有效了。

因而，对于这类表达式，它们首先是某个对象的标识，虽然没有名字。因而必然属于左值概念，但同时，它们之所以以右值引用的方式返回，其目的正是为了让别人将其所引用的对象资源move走，而一个对象的资源一旦被move走，对象本身就过期或失效，不应也不可再被访问。


对于这类表达式，C++11将它们归入一个新类别： **速亡值** （eXpire Value或xvalue)。

速亡值是一个无名右值引用，其所引用的对象，从理论上同样也是可以取其地址的。但由于其目的是为了让别人 ``move`` 其资源，取其地址之后，程序的其它部分将无从判断，这是一个来自于速亡值对象的地址，还是一个来自于左值对象的地址，从而容易导致危险的操作。因而，对其取地址操作被禁止。


必须要强调的是，右值引用类型本身并不代表速亡值。前者是类型，后者是表达式。一个表达式的类型是右值引用，也不代表这个表达式属于速亡值。比如： ``Foo&& foo = Foo{10}`` ; 表达式 ``foo`` 的类型是一个右值引用，但它属于左值。而上述的 ``f()`` ，其类型也是一个右值引用，它则属于速亡值。类似的还有 ``static_cast<Foo&&>(foo)`` ，这个表达式也属于速亡值。


但类型为右值引用的任何表达式，都必然属于泛左值。毕竟泛左值属于对象概念，右值引用也是对象的一种标识。


纯右值物质化
++++++++++++++++++++++++

``Foo&& foo = f()`` ，表达的是，将一个速亡值初始化给一个左值。

我们再回到前面的问题： ``Foo&& foo = Foo{10}`` 表达了什么语意？毕竟右边的是值，而左边是一个对于对象的引用。

这中间隐含着一个过程：将纯右值的物质化。即将一个纯右值，赋值给一个速亡值对象。然后再将这个速亡值对象初始化给等号左侧的左值。

纯右值物质化的过程还发生在其它场景。比如，最典型的场景，如果一个纯右值的类型是一个类，例如： ``Foo{10}`` ，就是一个纯右值表达式，但对于这个纯右值，我们试图访问其非静态成员，比如： ``Foo{10}.m`` ，此时就必需要将这个纯右值物质化，转化成速亡值。毕竟，对于任何非静态成员的访问，都需要对象的地址，与成员变量所代表的偏移两部分配合。没有对象的存在，仅靠偏移量访问其成员，完全无意义。

在c++17之前的规范定义中，将 **纯右值** 和 **速亡值** 合在一起，称为 **右值** 。代表它们都是可以被 ``move`` 的。在进行重载匹配时，右值会优先匹配右值引用参数。比如：

.. code-block:: c++

   void func(Foo&&);       // #1
   void func(const Foo&);  // #2

   Foo&& f();


   func(Foo{10}); // #1
   func(f());     // #1

   Foo foo{10};
   func(foo);     // #2

   Foo&& foo1 = Foo{10};
   func(foo1);    // #2



到了C++17，从匹配行为上没有变化，但语意上却有了变化。最终导致匹配右值引用版本的不是右值类别，而是速亡值。因为纯右值会首先进行物质化，得到一个速亡值。最终是用速亡值初始化了对应函数的参数。

而构造函数的匹配，一个纯右值，永远也无法匹配到 ``move`` 版本。因为 ``Foo foo = Foo{10}`` 与 ``Foo foo{10}`` 等价。而不再是将纯右值进行物质化，得到一个速亡值，然后匹配到 ``move`` 构造函数的过程。只有速亡值，才能匹配到 ``move`` 构造。比如： ``Foo foo = std::move(Foo{10})`` 将会导致 ``move`` 构造的调用。


.. attention:

   - 所有的表达式都可以归类为纯右值和泛左值；
   - 所有的纯右值都是值的概念；所有的泛左值都是对象的概念；
   - 纯右值在某些场景下会通过物质化，转化成速亡值。
   - 并非所有右值引用类型的表达式都属于速亡值；有名字的属于左值；无名字的才属于速亡值；
   - 左值可以求地址，速亡值不可以求地址；
   - 泛左值可以是抽象类型和不完备类型，纯右值只能是具体类型；

















