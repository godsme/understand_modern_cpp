引用
===================

引用是 `C` 语言所没有的概念。而这个概念，比它表面看起来要复杂一些。

左值
------------

为了理解引用，我们需要首先搞清楚什么叫 **左值** 。

简而言之，**左值** 是一种 **对象** ，而不是 **值** 。其关键区别在于，是否明确在内存中有其可访问的位置。
即，其是否存在一个可访问的地址。如果有，那么它就是一个 **对象** ，也就是一个 **左值** ，否则，它就只是
一个 **值** ，即 **右值** 。

比如：你不可能对整数 ``10`` 取地址，因而这个表达式是一个 **右值** 。但是如果你定义了一个变量：

.. code-block:: c++

   int a = 10;

变量 ``a`` 则代表一个 **对象** ，即 **左值** 。

任何可以取地址的表达式，背后都必然存在一个 **对象** ，因而也必然属于 **左值** 。而如果我们把对象地址看作其 **身份证** ( `Identifier` ），
那么我们也可以换句话说：任何有 **身份证** 的表达式，都属于 **左值** ；否则，肯定属于 **右值** 。

别名
-------------

**引用** 是 **对象** 的 **别名** 。

因而，**引用** 必然代表一个 **左值** 。

说它是 **别名** ，往往是因为一个 **左值** 往往会有一个名字：**变量** 或 **常量** 。而对于这些 **变量** 或者 **常量** 的 **引用** ，
本身并不像 **指针** 一样，需要额外占有一块（机器可寻址宽度）的内存。

正是因为其 **别名** 语义， `C++` 没有规定 **引用** 的尺寸（事实上，从 **别名** 语义的角度，它本身不需要内存，因而也就没有尺寸而言）。

因而，如果你试图通过 ``sizeof`` 去获取一个 **引用** 的大小，是不可能的。你只能得到它所引用的对象的大小（由于别名语义）。

.. code-block:: c++

   struct Foo {
     std::size_t a;
     std::size_t b;
   };

   Foo foo;
   Foo& ref = foo;

   static_assert(sizeof(ref) == sizeof(Foo));

也正是由于其别名语义，当你试图对一个引用取地址时，你得到的是对象的地址。比如，在上面的例子中，
``&ref`` 与 ``&foo`` 得到的结果是一样的。


因而，当你定义一个指针时，指针自身即为一个对象，即左值；它本身有自己明确的存储，并可以取自己的地址，可以通过 ``sizeof`` 获取自己的尺寸。

但是 **引用** ，本身不是一个像指针那样的额外对象，而是一个对象的别名，你对引用进行的任何操作，都是其所引用的对象的操作。在上面的例子中，``ref`` 与 ``foo`` 没有任何
差别，都是对象的一个名字而已。它们本身都代表一个对象，都是一个左值表达式。

因而，在不必要时，编译器完全不需要为引用分配任何内存。

空间
----------

但是，当你需要在一个数据结构中保存一个引用，或者需要传递一个引用时，你事实上是在存储或传递对象的 **身份**（即地址）。

虽然这并不意味着 ``sizeof(T&)`` 就是引用的大小（从语义上，引用自身非对象，因而无大小，``sizeof(T&) == sizeof(T)`` ），但对象的地址的确
需要对应的空间来存储。

.. code-block:: c++

   struct Bar {
      Foo& foo;
   };

   // still, reference keeps its semantics.
   static_assert(sizeof(Bar::foo) == sizeof(Foo));

   // but its storage size is identical to a pointer
   static_assert(sizeof(Bar) == sizeof(void*));

   // interesting!!!
   static_assert(sizeof(Bar) < sizeof(Bar::foo));


受限的指针
-------------------

在传递或需要存储时，一个引用的事实空间开销与指针无异。因而，在这些场景下，它经常被看作一个受限的指针：

首先，一个引用必须初始化。这是因为其 **对象别名** 语义，因而不引用任何对象的引用，从语义上就不成立。

其次，一个引用不可能从引用一个对象，修改为引用 **另外** 一个对象。原因很简单，依然由于其 **对象别名** 语义。它
本身就代表它所引用的对象，重新引用另外一个对象，从概念上不通。

而引用的 **不可更换性** ，导致任何存在引用类型非静态成员的对象，都不可能直接实现 **拷贝/移动赋值** 函数。
因而，标准库中，需要存储数据的，比如 **容器** ， ``tuple`` , ``pair`` , ``optional`` 等等结构，都不允许
存储 **引用** 。

第三，由于引用必须通过初始化引用某一个对象，因而从语义上，不存在空引用的概念。这样的语义，对于我们的接口设计，有着很好的帮助：
如果一个参数，从约束上就不可能是空，那么就不要使用指针，而使用引用。这不仅可以让被调用方避免不必要的空指针判断；最重要的是
正确的约束表达。

.. attention::

   **空引用** 从概念上是不存在的，但从事实上是可构造的。比如： ``T& ref = *(T*)nullptr`` 。

   因而，在项目中，任何时候，需要从指针转为引用时，都需要确保指针的非空性。

   另外，**空引用** 本身这个概念就是不符合语义的，因为引用只是一个对象的别名。上面的表达式，事实上站在对象角度同样可以构造: ``T obj = *(T*)nullptr`` 。
   时刻不要忘了这个语义：所有对于 **引用** 的操作，都是对 **对象** 的操作。







