C++编译时元编程
================================

`C++` 编译时元编程，是对 **类型** 和 **值** 的计算。类型自不必说，不存在 ``mutable`` 的可能性；而数值，`C++` 也规定了
必须是常量，即 ``immutable`` 的数值即对象。而任何基于常量的计算，如果其计算能力是图灵完备的，那么其从实际效果上，必然与
函数式编程是等价的。

为了理解 `C++` 编译时元编程的思想，最好有一门函数式编程语言做为引导。最为知名的函数式编程语言 `Haskell` 是一个直觉上最佳的选择。
不幸的是，由于 `C++` 编译时，不仅仅可以操纵 **数值** ，还可以操纵 **类型** ，而这两者高度融合在一个体系中，没有清晰界限。
但 `Haskell` 对于类型和数据区分的非常清楚：其每个数据都有自己的类型，但参与计算的是数据，没有计算类型的能力。
而 `Agda` 的类型系统高了一个层次，在计算层面，数值和类型的边界被消除，拥有同等的计算能力。因而，本文通过 `Agda` 来做为引导，来理解
`C++` 编译时元编程的思想。

我们先来看一段 `Agda` 代码：

.. code-block:: agda
   :linenos:

   data List (A : Set) : Set where
     []   : List A
     _::_ : A -> List A -> List A


这段代码里，``data`` 说明这是在定义一个数据类型，其名字是 ``List`` ， 而这个类型，需要另外一个类型做为输入，即 ``A`` ，而
``A`` 的类型为 ``Set`` ；而被定义的类型： ``List``， 其类型也是 ``Set`` 。

在类型系统理论中，每一个类型都是一个 **集合** ，比如：``bool`` 是一个集合，集合里的元素是其 **值域** ： ``true`` 和 ``false`` 。
而 ``int`` 则是整个整数集合。加法类型，即 `C/C++` 中的 `union` ，其 **值域** 则是 ``union`` 中每种类型 **值域** 的并集
（这就是为何被称做加法类型）；而乘法类型，即 `C/C++` 中的 `struct` ，其 **值域** 则是 ``struct`` 中每个 ``field`` 的
**值域** 相乘 。总之，不难理解，每一个类型都是一个集合。

但所有类型放在一起，也是一个集合。这个集合被称做 ``Set1`` 。之所以被叫做 ``Set1`` ，因为理论上，所有的
``Set1`` 也是一个集合，那个集合被称做 ``Set2`` ，从而可以 ``Set3, ..., SetN, ...'' 无穷的递归上去。

当然，我们现实中的类型系统，到 ``Set1`` 即足够了。所以上面代码中的 ``Set`` ，就是 ``Set1`` ，即所有类型的集合。因而，任何时候
你看到一个符号的类型是 ``Set`` ，那就意味着那个符号是一个类型。

接着看上面的代码。第 2 行和第 3 行，分别定义了两个 ``构造函数`` ：

1. 第一个构造了一个空列表，其类型当然是 ``List A`` ；
2. 第二个构造函数有两个参数： 类型分别为 ``A`` 和 ``List A`` ，
   即把一个 ``A`` 类型的数据追加到列表前面，得到计算结果：一个新的列表。
   这就是 ``A -> List A -> List A`` 的含义。


如果我们把上述代码直接映射到 `C++` ，就是下面的代码：

.. code-block:: c++

   template <typename A>
   struct List {
      List();
      List(A, List<A>);
   };

请花上一点时间，仔细对照这两段代码。它们之间的语意映射关系相当直接和清楚。
这其中，``typename`` 正是 ``Agda`` 中的 ``Set`` 。另外， `C++` 的构造函数的返回值类型正是其构造的类型本身，因而无须描述。

你或许会感叹 `Agda` 可以直接使用符号来定义构造。但那不是本文的重点。



