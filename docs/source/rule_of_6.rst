
六大金刚
=============================

任何一个 ``C++`` 类，总会面临六大特殊函数的问题：

  1. default 构造
  2. copy 构造
  3. move 构造
  4. copy 赋值
  5. move 赋值
  6. 析构

它们之间的关系，在如下层面互相影响：

  * 存在性
  * 操作性
  * 平凡性

而能力，与存在性有关，但又不完全相同。比如，一个类，移动构造函数可以不存在，却是能够移动构造的
（即 ``Foo foo2{std::move(foo1)}`` 是合法的表达式）。

而平凡性，则是能力的进一步约束。你能够被默认构造，但却不能被平凡构造。


存在性
--------------

所谓 **存在性** ，单纯指在一个类中，它的定义是否存在，无论是用户自己定义的还是系统默认生成的。

首先，对于任何一个特殊函数，如果用户明确定义或声明了它（ ``=default`` )，它都明确地存在。
其次，对于任何一个特殊函数，如果用户明确的删除了它，它都明确地不再存在。


而当系统决定默认生成某个特殊函数时，依然面临无法生成的困境。比如，其某个非静态成员变量，或者某个父类，将那个特殊函数删除了，
或者访问被禁止了，则系统也会放弃对此特殊函数的生成。

所以，我们下面只讨论在可生成的情况下，系统是否会默认生成某个特殊函数的场景。

默认构造
++++++++++++

只要用户明确声明了构造函数列表（包括 `copy/move` 构造），系统就不会自动生成默认构造。

注意，用户明确声明，并不是指用户自定义。哪怕用户明确的声明了 ``default/delete`` 某个构造，用户也就提供了明确的构造函数列表。比如：

.. code-block:: c++

   struct Thing {
      Thing(Thing&&) = delete;
   };

在这个用户明确声明的构造函数列表中，并不能查到默认构造函数，因而其并不存在。

如果用户没有明确声明任何构造函数。编译器将会尽力为它生成一个。除非编译器发现完全无法做到。
比如，某个非静态成员变量没有默认构造函数。

Copy 构造
+++++++++++

`copy` 构造则在 **构造三杰** 中，地位最高。

如果用户没有提供任何构造函数列表，系统会尽力为其生成一个。

如果用户提供了构造函数列表，即便其中查不到 **`copy` 构造** ，但 **`move` 家族** （ `move` 构造/赋值）没有被明确声明，
那么系统会尽力生成一个 **`copy` 构造** 。

.. code-block:: c++

   struct Thing {
      Thing() {}
      // 隐式生成一个copy构造
      // Thing(Thing const&) = default;
   };

.. code-block:: c++

   struct Thing {
      Thing(Thing&&) = delete;
      // copy构造被删除
      // Thing(Thing const&) = delete;
   };

.. code-block:: c++

   struct Thing {
      Thing(Thing&&) = default;
      // copy构造被删除
      // Thing(Thing const&) = delete;
   };

.. code-block:: c++

   struct Thing {
      auto operator=(Thing&&) -> Thing& = default;
      // copy构造被删除
      // Thing(Thing const&) = delete;
   };

.. code-block:: c++

   struct Thing {
      auto operator=(Thing&&) -> Thing& = delete;
      // copy构造被删除
      // Thing(Thing const&) = delete;
   };

所以它的默认存在性，只受 **`move` 家族** 的影响。

Move构造
+++++++++++++

**`move` 构造** 则在 **构造三杰** 中，最为脆弱。

如果用户明确声明了如下任何一个，系统都不会自动生成move构造：

  * copy构造
  * copy赋值
  * move赋值
  * 析构函数

所以其默认存在性，不仅受 **copy家族** 和 **析构** 的影响，还会遭受本家族另一成员的攻击。


