SFINAE
==================

`SFINAE` 是 `Substitution Failure Is Not An Error` ( **替换失败不是一个错误** ) 的缩写。
在 `C++11` 之前，这并不是一个正式的 `C++` 规范术语。而是由 `David Vandevoorde` 在其书籍
``C++ Templates: The Complete Guide`` 首次命名的概念。

整个术语有三个关键词：

  1. 替换
  2. 失败
  3. 错误

如果不能理解它们背后的准确含义，就很难正确的理解并应用 `SFINAE` 。

函数重载
---------------------

之所以会存在 `SFINAE` ，关键在于两点：

   1. `C++` 允许函数重载；
   2. `C++` 有函数模版；

没有这两点，`SFINAE` 也无从谈起。

而允许 **函数重载** ，就意味着，同一个函数名，可能存在多个版本的定义。

因而，当你的代码中出现 **函数调用** 时，编译器需要弄明白，此 **函数调用** 究竟调用的是那个版本。而这个弄明白的过程，
被称作 `Overload Resolution` ( **重载决议** ) 。

其大致的过程如下：

  1. 编译器首先会根据 `C++` 规范所定义的 **名字查找** 规则，找到所有符合名字查找规则的同名函数，作为 **候选集** 。
  2. 将 **候选集** 里完全不匹配的版本踢出（比如参数个数不匹配）。
  3. 如果剩余的 **候选集** 里存在 **模版函数** ，则需要对模版参数进行推演。而推演的过程，包含一个环节： `Substitution` ，即 **替换** ，
     `SFINAE` 正是发生在这个环节：如果替换失败，编译器不会给出任何诊断信息，只是简单的将这个函数踢出 **候选集** 。如果替换成功，此模版函数
     就被实例化为一个普通函数。
  4. 到这一步依然还剩下的候选集，被称作 `viable candidates` （ **可行候选集** ）。编译器下一步的任务是从 **可行候选集** 中
     找到 **最匹配** 的版本。而这可能会导致三种结局：

     - 找到了最匹配的版本。编译器将选择这个版本。
     - 剩余的候选集为空。这将导致编译错误，编译器会抱怨找不到合适的定义。
     - 存在超过一个 **最匹配** 的版本。这会导致二义性，也会造成编译错误。

  5. 如果找到了最匹配版本，编译器还会进行其它检查（可见性，是否被声明为 ``=delete`` 等等）。

从这个过程我们就可以明确 `SFINAE` 的含义：某个函数调用的 **候选集** 中，如果存在 **模版函数** ，则会对模版参数进行推演并替换，
而 **替换失败** 不会直接导致 **编译错误** ，只会导致编译静悄悄地将此 **模版函数** 从 **候选集** 中移出。














